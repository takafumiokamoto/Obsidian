# Guide to Self-Hosted GitHub Runner on AWS ECS with GitHub App and EC2
Created: 6/16/2025, 2:18:40 PM
Last Updated: 6/16/2025, 3:27:25 PM
---

### User

I want to set up a self-hosted runner for GitHub and have decided to use AWS ECS  for hosting.
However, I have two concerns with this approach:
Firstly, a Personal Access Token (PAT) is required to retrieve the runner registration token on startup, which I would like to avoid.
Secondly, since Fargate doesn't allow privileged containers, running Docker commands inside the self-hosted runner will be problematic. therefore, I want to use EC2 lauch type.
I would like you to create a comprehensive guide to solve this problem.
The guide must meet the following requirements:
- Use GitHub App for authentication.
- Use CloudFormation to create AWS resources.
- Use Python to create an entrypoint script for the Docker container.
- Use the docker-in-docker sidecar pattern.

To start, could you please show me the title of each step? I will ask you about them individually afterwards.


---

### Assistant (gemini-2.5-pro)

<details>
<summary>Reasoning</summary>

**Outlining the Guide Structure**

I've just begun deconstructing the user's request. My focus now is on understanding the core goal - setting up a self-hosted GitHub runner on AWS ECS. I'm noting the specific host, AWS ECS, and the EC2 launch type. I'm mapping the essential components. The goal is to provide a comprehensive guide.


**Developing the Step Sequence**

I'm now prioritizing the order of steps. My aim is to organize a logical flow, beginning with GitHub App setup, transitioning to AWS infrastructure provisioning via CloudFormation, and culminating in the Docker image creation and entrypoint script configuration. I'm focusing on a clean, linear presentation to guide the user seamlessly through the setup process.


**Refining Step Sequencing**

I'm now prioritizing the order of steps. My aim is to organize a logical flow, beginning with GitHub App setup, transitioning to AWS infrastructure provisioning via CloudFormation, and culminating in the Docker image creation and entrypoint script configuration. I'm focusing on a clean, linear presentation to guide the user seamlessly through the setup process.

**Adjusting Detail Granularity**

I'm currently focused on determining the level of detail for each step. The goal is a balance between helpful guidance and information overload. I'm striving for the right combination of high-level descriptions and actionable tips that provide sufficient context. I will aim to deliver a "comprehensive guide" to get the job done and tested.


**Finalizing Step Granularity**

I'm now focusing on the final step titles, ensuring they're clear and actionable. My goal is to craft titles that communicate purpose, not just action. I'm prioritizing clarity and context. I'll need to specify what a developer would need to do first, second, and so on. Now, I'm working to consolidate the sub-components within the CloudFormation step.


**Organizing Finalized Steps**

I've determined the final step titles, ensuring each conveys purpose. I've consolidated CloudFormation components into a single step, breaking it down further for clarity. My focus now is on deploying the ECS Service using the Task Definition. I'm also planning to create a container within the ECS to run the service. The goal is to provide a step-by-step guide.


**Defining Step Titles Iteratively**

I'm now iterating on the step titles, focusing on clarity and actionability. The goal is to ensure each title communicates both the 'what' and the 'why.' For example, I'm refining "Define AWS Infrastructure with CloudFormation" to incorporate the components it contains, such as networking, IAM roles, and ECS cluster configuration. This will give the user a clear expectation of what to expect within each step, thus, I can provide more information on sub-components in the CloudFormation step.


**Outlining Step Sequencing**

I'm now prioritizing the order of steps. My aim is to organize a logical flow, beginning with GitHub App setup, transitioning to AWS infrastructure provisioning via CloudFormation, and culminating in the Docker image creation and entrypoint script configuration. I'm focusing on a clean, linear presentation to guide the user seamlessly through the setup process.

I've revised the step sequencing to include authentication, infrastructure provisioning, container development, task definition creation with the DinD sidecar, ECS service creation, and deployment verification. This flow ensures a logical progression, starting from GitHub App setup and ending with a comprehensive solution. This also reflects a more user-centric approach that ensures all the essential elements are covered.



</details>

Of course. Creating a secure, scalable, and maintainable self-hosted runner environment on AWS ECS is an excellent project. Using a GitHub App is the modern, recommended approach for authentication, and the Docker-in-Docker (DinD) sidecar pattern is a clever way to handle Docker builds on the EC2 launch type.

Here is the proposed structure for the comprehensive guide, broken down into logical steps.

***

### **Guide: Self-Hosted GitHub Runners on AWS ECS with GitHub Apps and Docker-in-Docker**

**Step 1: Create and Configure a GitHub App for Authentication**

**Step 2: Generate a Private Key and Store Credentials in AWS Secrets Manager**

**Step 3: Define Core AWS Infrastructure with CloudFormation**

**Step 4: Develop the Runner Container Image with a Python Entrypoint**

**Step 5: Create the ECS Task Definition with a Docker-in-Docker (DinD) Sidecar**

**Step 6: Create the ECS Service to Run and Scale the Runners**

**Step 7: Deploy and Verify the Solution**

***

You can now ask me about each step individually, and I will provide the detailed explanation, code, and CloudFormation templates required.


---

### User

Let's jump to Step 3


---

### Assistant (gemini-2.5-pro)

<details>
<summary>Reasoning</summary>

**Analyzing the Prompt's Core**

I'm currently breaking down the user's request.  The core is defining AWS infrastructure, specifically for "Step 3: Define Core AWS Infrastructure with CloudFormation." The aim seems to be self-hosting, which adds further nuance.


**Refining Infrastructure Scope**

I'm now zeroing in on the "core" aspect. The user wants to avoid unnecessary complexity for a self-hosted runner setup. This means focusing on the bare essentials: a VPC, subnets, an Internet Gateway, and route tables for the network. Then, an ECS cluster configured for EC2 instances and the security groups. I believe these are the critical pieces to deliver the foundation for the EC2 launch.


**Prioritizing Resource Sequencing**

I've been thinking about the order of creation. Network components must be established first.  Then, I'll focus on the ECS cluster and the Launch Template for EC2 instances within the defined VPC. The security groups will need to be configured correctly and attached to the infrastructure. Finally, the Auto Scaling Group can launch the EC2 instances.


**Defining IAM and Logging**

I'm now prioritizing the necessary IAM roles and policies. The EC2 instance role requires the `AmazonEC2ContainerServiceforEC2Role` managed policy and a custom policy for accessing the runner secrets. I'll also define a CloudWatch Log Group to capture container logs. This is key for monitoring and troubleshooting. I'll make sure the Log Group has appropriate retention settings as well.


**Developing Template Logic**

I'm now focusing on the CloudFormation template's structure. Parameters will include the cluster name, instance type, and the ARN of the secret. Resources will be grouped logically: VPC, subnets, internet gateway, route tables, security groups, IAM roles, CloudWatch log group, ECS cluster, Launch Template, and Auto Scaling Group. Outputs will provide the cluster name, security group ID, subnet IDs, and the EC2 instance role ARN.


**Defining Runner Permissions**

I'm now formulating the fine-grained permissions for the runner. The EC2 instance role requires `secretsmanager:GetSecretValue` on the specific secret ARN provided as a parameter. This ensures the runner can securely access its credentials. I'll also add a policy for reading the ECR repository if private images are used, and  the necessary permissions for `ecs:Poll`, `ecs:StartTask`, `ecs:StopTask`, `ecs:DescribeTasks` as well as CloudWatch logging.



**Defining Instance Permissions**

Now, I'm defining the necessary IAM permissions for the EC2 instances. The instances require the `AmazonEC2ContainerServiceforEC2Role` policy, along with specific access to the Secrets Manager to retrieve the runner credentials. I'll include a policy with `secretsmanager:GetSecretValue` on the secret ARN and also ECR access. This is essential for pullling the GitHub Actions Runner image.

**Defining Fine-Grained Permissions**

I'm now focusing on the essential IAM and security configurations for the runner. The EC2 instance role is granted the necessary permissions through `AmazonEC2ContainerServiceforEC2Role` policy. Additionally, I'll ensure the role can access the specified secret from Secrets Manager, adding `secretsmanager:GetSecretValue` on the secret ARN and also ECR access. This is essential for both retrieving the credentials and pulling the runner image from ECR, if the image is private. I'll make sure there is a CloudWatch Log Group defined, with the right permissions.


**Optimizing Template Deployment**

I'm currently focused on the deployment process. To make it easier for the user, I'll provide clear instructions and a sample command. I'm considering using `Fn::Sub` for resource names to enhance readability and ensure uniqueness. It's crucial the user understands the key parameters, specifically the secret ARN and cluster name. I'll make sure to highlight this in the instructions.




</details>

Excellent. Let's dive into creating the foundational AWS infrastructure. This step is crucial as it sets up the network, permissions, and compute resources where your runners will operate.

***

### **Step 3: Define Core AWS Infrastructure with CloudFormation**

In this step, we will create a CloudFormation template to provision the core AWS resources. This "core stack" will include:

*   **Networking:** A new VPC with public subnets, an Internet Gateway, and route tables to allow our runners to communicate with GitHub.
*   **IAM Role:** A specific IAM Role for our EC2 instances. This role will grant the necessary permissions to connect to the ECS cluster and, critically, to fetch the GitHub App credentials from AWS Secrets Manager.
*   **ECS Cluster:** A logical grouping for our runner services.
*   **EC2 Auto Scaling Group:** This will manage the EC2 instances that join our ECS cluster. We will use a Launch Template to define the instance configuration, ensuring they use the latest ECS-optimized AMI.
*   **Logging:** A CloudWatch Log Group to store logs from our runner containers for easier debugging.

Using CloudFormation ensures our infrastructure is reproducible, version-controlled, and easy to manage.

---

#### **CloudFormation Template: `core-infra.yml`**

Below is the complete CloudFormation template. I've included comments to explain what each section does.

```yaml
AWSTemplateFormatVersion: "2010-09-09"
Description: >
  Core infrastructure for self-hosted GitHub runners on ECS with EC2.
  This stack creates a VPC, Subnets, an ECS Cluster, and an Auto Scaling
  Group of EC2 instances ready to host runner containers.

Parameters:
  ClusterName:
    Type: String
    Default: "github-runners-cluster"
    Description: The name for the ECS Cluster.
  InstanceType:
    Type: String
    Default: "t3.medium"
    Description: EC2 instance type for the ECS container instances.
  DesiredCapacity:
    Type: Number
    Default: 1
    Description: Desired number of EC2 instances in the Auto Scaling Group.
  MaxSize:
    Type: Number
    Default: 5
    Description: Maximum number of EC2 instances in the Auto Scaling Group.
  SecretArn:
    Type: String
    Description: The full ARN of the AWS Secret containing the GitHub App credentials.

Resources:
  # ------------------------------------------------------------#
  # Networking
  # ------------------------------------------------------------#
  VPC:
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: "10.0.0.0/16"
      EnableDnsSupport: true
      EnableDnsHostnames: true
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-VPC"

  PublicSubnet1:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      CidrBlock: "10.0.1.0/24"
      AvailabilityZone: !Select [0, !GetAZs ""]
      MapPublicIpOnLaunch: true
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-PublicSubnet1"

  PublicSubnet2:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      CidrBlock: "10.0.2.0/24"
      AvailabilityZone: !Select [1, !GetAZs ""]
      MapPublicIpOnLaunch: true
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-PublicSubnet2"

  InternetGateway:
    Type: AWS::EC2::InternetGateway
    Properties:
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-IGW"

  VPCGatewayAttachment:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      VpcId: !Ref VPC
      InternetGatewayId: !Ref InternetGateway

  PublicRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref VPC
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-PublicRouteTable"

  PublicRoute:
    Type: AWS::EC2::Route
    DependsOn: VPCGatewayAttachment
    Properties:
      RouteTableId: !Ref PublicRouteTable
      DestinationCidrBlock: "0.0.0.0/0"
      GatewayId: !Ref InternetGateway

  Subnet1RouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PublicSubnet1
      RouteTableId: !Ref PublicRouteTable

  Subnet2RouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PublicSubnet2
      RouteTableId: !Ref PublicRouteTable

  # ------------------------------------------------------------#
  # Security & IAM
  # ------------------------------------------------------------#
  ECSSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: "Allow communication for ECS instances and containers"
      VpcId: !Ref VPC
      SecurityGroupIngress:
        # This self-referencing rule is crucial for the Docker-in-Docker sidecar.
        # It allows the runner container to communicate with the DinD container
        # over the shared Docker socket volume.
        - Description: "Allow all traffic from within the security group"
          IpProtocol: "-1"
          FromPort: -1
          ToPort: -1
          SourceSecurityGroupId: !GetAtt ECSSecurityGroup.GroupId
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-ECSSecurityGroup"

  EC2InstanceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: [ec2.amazonaws.com]
            Action: ["sts:AssumeRole"]
      ManagedPolicyArns:
        - "arn:aws:iam::aws:policy/service-role/AmazonEC2ContainerServiceforEC2Role"
      Policies:
        - PolicyName: "SecretsManagerGetSecretValue"
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action: "secretsmanager:GetSecretValue"
                Resource: !Ref SecretArn

  EC2InstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Path: "/"
      Roles:
        - !Ref EC2InstanceRole

  # ------------------------------------------------------------#
  # ECS Cluster & Compute
  # ------------------------------------------------------------#
  ECSCluster:
    Type: AWS::ECS::Cluster
    Properties:
      ClusterName: !Ref ClusterName

  RunnerLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub "/ecs/${ClusterName}"
      RetentionInDays: 30

  LaunchTemplate:
    Type: AWS::EC2::LaunchTemplate
    Properties:
      LaunchTemplateName: !Sub "${AWS::StackName}-LaunchTemplate"
      LaunchTemplateData:
        ImageId: !Resolve ssm:/aws/service/ecs/optimized-ami/amazon-linux-2/recommended/image_id
        InstanceType: !Ref InstanceType
        IamInstanceProfile:
          Arn: !GetAtt EC2InstanceProfile.Arn
        SecurityGroupIds:
          - !Ref ECSSecurityGroup
        UserData:
          Fn::Base64: !Sub |
            #!/bin/bash
            echo ECS_CLUSTER=${ClusterName} >> /etc/ecs/ecs.config

  AutoScalingGroup:
    Type: AWS::AutoScaling::AutoScalingGroup
    Properties:
      VPCZoneIdentifier:
        - !Ref PublicSubnet1
        - !Ref PublicSubnet2
      LaunchTemplate:
        LaunchTemplateId: !Ref LaunchTemplate
        Version: !GetAtt LaunchTemplate.LatestVersionNumber
      DesiredCapacity: !Ref DesiredCapacity
      MinSize: !Ref DesiredCapacity
      MaxSize: !Ref MaxSize
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-ECSInstance"
          PropagateAtLaunch: true

Outputs:
  ClusterName:
    Description: "The name of the ECS Cluster"
    Value: !Ref ECSCluster
  ECSSecurityGroupId:
    Description: "The ID of the ECS Security Group"
    Value: !Ref ECSSecurityGroup
  PublicSubnet1Id:
    Description: "ID of the first public subnet"
    Value: !Ref PublicSubnet1
  PublicSubnet2Id:
    Description: "ID of the second public subnet"
    Value: !Ref PublicSubnet2
  EC2InstanceRoleArn:
    Description: "ARN of the IAM Role for the EC2 instances"
    Value: !GetAtt EC2InstanceRole.Arn
```

---

#### **How to Deploy**

1.  **Save the Template:** Save the code above into a file named `core-infra.yml`.
2.  **Get Secret ARN:** Go to the AWS Secrets Manager console and copy the ARN of the secret you created in Step 2.
3.  **Deploy via AWS CLI:** Run the following command in your terminal, replacing `<YOUR_SECRET_ARN>` with the ARN you just copied.

    ```bash
    aws cloudformation deploy \
      --template-file core-infra.yml \
      --stack-name github-runner-core-infra \
      --parameter-overrides SecretArn=<YOUR_SECRET_ARN> \
      --capabilities CAPABILITY_IAM
    ```

    *   `--stack-name`: A unique name for your CloudFormation stack.
    *   `--parameter-overrides`: This is where we pass the required `SecretArn`.
    *   `--capabilities CAPABILITY_IAM`: This is required because the template creates IAM resources.

After a few minutes, the stack creation will complete. You will have a fully functional ECS cluster with EC2 instances ready and waiting. The instances have the correct permissions to pull the secret, and the networking is configured for them to reach the internet.

We are now ready to build the Docker container that will run on these instances. What would you like to do next?


---
